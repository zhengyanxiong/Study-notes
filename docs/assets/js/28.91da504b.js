(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{510:function(v,a,e){"use strict";e.r(a);var t=e(4),_=Object(t.a)({},(function(){var v=this,a=v.$createElement,e=v._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"什么是java的内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是java的内存模型"}},[v._v("#")]),v._v(" 什么是Java的内存模型？")]),v._v(" "),e("blockquote",[e("p",[v._v("导致可见性的原因是缓存，导致有序性的原因是编译优化，解决可见性、有序性最直接的办法就是"),e("strong",[v._v("禁用缓存")]),v._v("和"),e("strong",[v._v("编译优化")]),v._v("，但是需要"),e("strong",[v._v("按需")]),v._v("禁用缓存和编译优化。")])]),v._v(" "),e("p",[v._v("Java内存模型是指Java虚拟机（JVM）所使用的内存结构和操作规则，定义了多线程程序中的线程如何访问共享数据，并且确保这些访问是有序的、可靠和正确的。")]),v._v(" "),e("p",[v._v("Java的内存模型包括"),e("strong",[v._v("主内存")]),v._v("和"),e("strong",[v._v("工作内存")]),v._v("两部分。主内存是所有线程共享的内存区域，而工作内存是每个线程私有的内存区域。每个线程在执行过程中需要将共享变量从主内存复制到工作内存中，然后执行操作，最后将结果写回主内存。")]),v._v(" "),e("p",[v._v("总的说包括"),e("strong",[v._v("volatile")]),v._v("、"),e("strong",[v._v("synchronized")]),v._v("和"),e("strong",[v._v("final")]),v._v("三个关键字，以及六项"),e("strong",[v._v("Happens-Before")]),v._v("规则。")]),v._v(" "),e("h3",{attrs:{id:"volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[v._v("#")]),v._v(" volatile")]),v._v(" "),e("p",[v._v("使用volatile关键字可以保证可见性，即当一个线程修改了volatile变量的值后，其他线程能够立即看到这个修改的结果。")]),v._v(" "),e("blockquote",[e("p",[v._v("在1.5版本之前，"),e("code",[v._v("volatile")]),v._v("关键字并不能保证原子性，也就是说，如果多个线程同时修改同一个"),e("code",[v._v("volatile")]),v._v("变量，可能会出现竞争条件导致的非预期结果。从JDK 1.5开始，Java语言对"),e("code",[v._v("volatile")]),v._v("关键字的语义进行了扩展，除了保证可见性之外，还增加了禁止指令重排序和保证原子性的功能。因此，在JDK 1.5及以后的版本中，"),e("code",[v._v("volatile")]),v._v("关键字的作用更加强大。通过"),e("strong",[v._v("Happens-Before")]),v._v("规则解决的。")])]),v._v(" "),e("h3",{attrs:{id:"happens-before规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#happens-before规则"}},[v._v("#")]),v._v(" Happens-Before规则")]),v._v(" "),e("blockquote",[e("p",[v._v("前面一个操作的结果对后续操作是可见的")])]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("程序的顺序性规则")]),v._v("：按照程序顺序，前面的操作Happens-Before于后续的任意操作。")]),v._v(" "),e("li",[e("strong",[v._v("volatitle变量规则")]),v._v("：对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作。")]),v._v(" "),e("li",[e("strong",[v._v("传递性")]),v._v("：a happens-before b, b happens-before c, => a happens-before c")]),v._v(" "),e("li",[e("strong",[v._v("管程中锁的规则")]),v._v("：管程是一种同步原语，在Java中就是synchronized，是管程的实现。在进入同步块之前，会自动加锁，而在代码块执行完后自动释放锁，这个过程是编译实现的。")]),v._v(" "),e("li",[e("strong",[v._v("线程start()规则")]),v._v("：关于启动线程的，主线程A启动子线程B，子线程B能够看到主线程在启动B前的操作。")]),v._v(" "),e("li",[e("strong",[v._v("线程join()规则")]),v._v("：关于线程等待的，主线程能够看到子线程的操作。")])]),v._v(" "),e("h3",{attrs:{id:"synchronized"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#synchronized"}},[v._v("#")]),v._v(" synchronized")]),v._v(" "),e("p",[v._v("使用synchronized关键字可以保证原子性和可见性，即同一时刻只有一个线程能够执行synchronized代码块或方法。")]),v._v(" "),e("h3",{attrs:{id:"final"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#final"}},[v._v("#")]),v._v(" final")]),v._v(" "),e("p",[v._v("使用final关键字可以保证可见性和有序性，即当一个final变量被初始化后，其他线程能够立即看到这个初始化的结果，并且不会发生重排序。")])])}),[],!1,null,null,null);a.default=_.exports}}]);