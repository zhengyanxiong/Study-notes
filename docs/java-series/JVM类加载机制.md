---
title: JVM 类加载机制
date: 2020-11-25
---

### 1、概述

#### 1.1 定义

虚拟机把描述Java类的数据从`Class`文件**加载**到内存，并对数据进行**校验**，**转换解析**和**初始化**，最终形成可被**虚拟机**直接使用的Java类型的过程。

![类加载流程](img/171ce88f7303617a)

#### 1.2 特性

运行期间类加载。即在Java语言里，类的加载，连接和初始化过程都是在程序运行期完成的，从而通过牺牲一些性能开销来换取Java程序的高度灵活性。

> JVM运行期动态加载 + 动态链接 ->Java动态扩展特性

### 2、类加载过程

JVM类加载机制分为五个部分： **加载**，**验证**，**准备**，**解析**，**初始化**

![类加载过程](img/171ce88f75f701e0)

#### 2.1 加载

加载是类加载过程中的一个阶段，**这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为这个类在方法区的各种数据的入口**。

> 注意：这个里不一定非得从一个Class文件获取，这里既可以从jar包或war包中读取，也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。

#### 2.2 验证

这一阶段主要是为了 **确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求**，并且不会危害虚拟机自身的安全。

#### 2.3 准备

准备阶段是正式为类变量分配内存，并设置类变量的初始值，**即在方法区中分配这些变量所使用的内存空间**。

> 注意：这里说的初始值概念，当一个变量被定义为 **public static int v = 8080**，实际上变量 **v**在准备阶段过后的初始值为0，而不是8080，将 **v** 赋值为 8080 的 put static 指令是程序被编译后，存放于类构造器<client>方法中。但是如果申明为 **public static final int v = 8080**，在编译阶段会为 **v** 生成 **ConstantValue** 属性，在准备阶段会根据 **ConstantValue** 属性将 v 赋值为 8080.

#### 2.4 解析

解析阶段就是将**虚拟机中常量池的符号引用替换为直接引用的过程**。

七类符号及其对应在常量池的七种常量类型

- 类或接口（CONSTANT_Class_info）
- 字段（CONSTANT_Fileldref_info）
- 类方法（CONSTANT_Methodref_info）
- 接口方法（CONSTANT_InterfaceMethodref_info）
- 方法类型（CONSTANT_MethodType_info）
- 方法句柄（CONSTANT_MethodHandle_info）
- 调用点限定符（CONSTANT_InvokeDynamic_info）

#### 2.5 初始化

初始化阶段是类加载过程的最后一步，会开始真正执行类中定义的Java代码，而之前的类加载过程中，除了**加载**阶段，可以自定义类加载器外，其余阶段均由JVM主导控制。

初始化阶段是执行类构造器<client>方法的过程，<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行前，父类的<client>方法已经执行完毕，如果一个类中没有静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>方法。

### 3、类加载器&双亲委派

> 每个类加载器，都拥有一个独立的命名空间，它不仅用于加载类，还和这个类本身一起作为在`JVM`中的唯一标识。所以比较两个类是否相等，只要看它们是否由同一个**类加载器**加载，即使它们来源于同一个`Class`文件且被同一个`JVM`加载，只要加载它们的**类加载器不同，这两个类就必定不相等**.

#### 3.1 类加载器

虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3中类加载器：

##### 3.1.1 启动类加载器（Bootstrap ClassLoader）

负责加载 **JAVA_HOME\lib** 目录中的，或通过 **-Xbootclasspath** 参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。

##### 3.1.2 扩张类加载器（Extension ClassLoader）

负责加载 **JAVA_HOME\lib\ext** 目录中的，或通过 **java.ext.dirs** 系统变量指定路径中的类库。

##### 3.1.3 应用程序类加载器（Application ClassLoader）

负责加载用户路径（classpath）上的类库。

#### 3.2 双亲委派

当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求类委派给父类去完成，每一个层次类加载都是如此，因此所有加载请求都应该被传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求时（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

采用双亲委派的一个好处就是比如加载位于 rt.jar 包中类 java.lang.Object,不管是哪个类加载器加载这个类，最终都会委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。