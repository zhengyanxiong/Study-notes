---
title: 并发编程的源头
date: 2023-05-02
tags:
 - Java
 - 并发编程
categories:
 - Java系列
---

### 并发编程的源头

这些年，在科技快速发展的情况下，CPU、内存、I/O设备都在不断的迭代，不断的朝着更快的方向努力。但是在快速发展的过程中，有一个核心的矛盾存在，那就是三者的速度差异。

在程序里有大部分的需要需要访问内存，还有部分需要访问I/O，根据木桶理论，程序的整体性能取决于最慢的操作，这样但方面的提高CPU性能是无效的。

在为了平衡三者的差异：

- CPU增加了缓存（通常有L1,L2,L3，cpu访问过的内存数据，会放到缓存中，下次访问，会直接从缓存中读取，这个就减少了cpu等待从内存中获取数据的时间），以均衡与内存的速度差异；
- 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

现在我们程序就在使用这些伟大的创造，但是天下没有免费的午餐，并发程序很多诡异问题的根源就在这里。

### 源头1：缓存导致的可见性问题

单核时代，一个线程对共享变量的修改，另一个线程是可见的。

![image-20230502111834729](https://gitee.com/zhengyanxiong/picture-bed/raw/master/img/image-20230502111834729.png)

多核时代，每个CPU都有自己的缓存，当线程在不同的CPU上操作，就会出现数据的不可见行。

![image-20230502112232449](https://gitee.com/zhengyanxiong/picture-bed/raw/master/img/image-20230502112232449.png)

### 源头2：线程切换带来的原子性问题

操作系统的分时调用，将cpu划分成不同的时间片段，在其中一个时间片上任务执行结束后，当前cpu上的进程（线程）就会休眠让出资源的占用，这个时候就会发生“任务切换”。而操作系统发生任务切换是指令级别的，及一条指令完成后，都可能发生任务切换。**这里把一个或多个操作在CPU执行的过程中不被中断的特效成为原子性**，在我们高级编程语言中，通常很多操作都是由多条指令完成的。

### 源头3：编译优化带来的有序性问题

编译器为了优化性能，有时候会调整指令的执行顺序。

Java领域的双重检查创建单例对象。



