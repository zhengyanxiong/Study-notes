---
title: 互斥锁解决原子性问题
date: 2023-05-04
tags:
 - Java
 - 并发编程
categories:
 - Java系列
---

原子性问题的源头是线程切换，如果禁用线程切换，就可以解决原子性问题，这个方案在单核CPU时代是可行的，但是不适用于多核场景。

**同一时刻只有一个线程执行**，这个条件我们称之为**互斥**。

**synchronized**

- 修饰非静态方法，锁当前对象this
- 修饰静态方法，锁当前class
- 修改代码快，锁定义的对象

**锁和受保护资源的关系**

**受保护资源和锁之间的关联关系是N:1的关系**。

必须深入分析锁定的对象和受保护资源的关系，综合考虑保护资源的访问路径，多方面考量才能用好互斥锁。

在保护多个资源时，首先需要区分资源之间是否存在关联关系

#### 保护没有关联关系的多个资源

用不同的锁对受保护的资源进行细化管理，这样能够提升程序性能。这种锁也叫，**细粒度锁**。

::: tip
注意：细粒度的锁可能会导致死锁。
:::

#### 保护有关联关系的多个资源

使用共享的锁去实现。即这个锁的粒度更大，能够覆盖所有相关的资源。

::: tip
锁的粒度取决于资源之间的关系。
:::

比如转账的例子：

```java
class Account {
    private int balance;
    // 转账
    void transfer(Account target, int amt) {
        // Account.class是Java虚拟机加载Account类时创建的
        synchronized(Account.class) {
            if (this.balance > amt) {
                this.balance -= amt;
                target.balance += amt;
            }
        }
    }
}
```

下图展示了共享锁Accout.class保护不同对象的临界区。

![image-20230504230903700](https://gitee.com/zhengyanxiong/picture-bed/raw/master/img/image-20230504230903700.png)

::: warn
这里用Account.class作为互斥锁，虽然解决了并发问题，但是所有的转账操作都是串行的。性能差。
:::

所以提高程序性能还是需要细粒度的锁，能够提高程序的并行度，下图展示了细粒度锁的逻辑图。

![image-20230504232616527](https://gitee.com/zhengyanxiong/picture-bed/raw/master/img/image-20230504232616527.png)

不过这种情况会出现死锁动作。

#### 如何预防死锁

只要同时满足这四个条件，才会出现死锁：

- 互斥，共享资源X和Y只能被一个线程占用
- 占有且等待，线程T1以及获取了共享资源X，在等待共享资源Y的时候，不释放共享资源X
- 不可抢占，其他线程不能抢占T1占有的资源
- 循环等待，线程T1等待线程T2占用的资源，线程T2等待线程T1占有的资源

要避免死锁，只需要破坏这四个条件中的一个，就可以。其中互斥这个条件没法破坏，加锁的目的就是互斥。

**破坏占有且等待**

1. 一次性申请所有的资源：当进程或线程需要多个资源时，可以在开始时一次性申请所有的资源，而不是逐个申请。如果无法一次性申请所有资源，则释放已经占用的资源，等待所有资源都可用时再重新申请。这样可以破坏占有且等待条件，从而避免死锁的发生。
2. 先释放已经占用的资源再申请新的资源：当进程或线程需要占用新的资源时，可以先释放已经占用的资源，然后再申请新的资源。如果无法获得新的资源，则可以再次申请已经释放的资源。这样可以破坏占有且等待条件，从而避免死锁的发生。

**破坏不可抢占**

1. 超时机制：如果占用资源的线程申请不到其他资源，就释放自己占有的资源。
2. 优先级倒置：优先级倒置是指当低优先级的进程占用了高优先级的资源时，高优先级的进程可以抢占低优先级的资源，以确保高优先级进程的执行。这样可以破坏不可抢占条件，从而避免死锁的发生。
3. 可抢占资源：可抢占资源是指某些资源在被占用时，可以被其他进程或线程抢占。这样，当一个进程或线程等待某个资源时，其他进程或线程可以强制其释放已占用的资源，从而避免死锁的发生。

**破坏循环等待**

1. 资源有序分配：资源有序分配可以破坏循环等待条件。具体方法是，为每个资源分配一个序号，并规定进程只能按照序号递增的顺序请求资源。这样，当多个进程都需要多个资源时，它们必须按照相同的顺序请求资源，从而避免了循环等待的情况。
2. 资源剥夺：资源剥夺是指操作系统在必要时可以剥夺一个进程已经占用的资源，将其分配给其他进程使用。当一个进程请求一个资源时，如果该资源已经被其他进程占用，那么操作系统可以将该资源从该进程中剥夺，并分配给当前请求该资源的进程使用。这样可以破坏循环等待条件，从而避免死锁的发生。
3. 按顺序申请资源：进程在申请资源时，按照某种固定的顺序来申请资源，而不是一次性申请所有的资源。当一个进程申请不到某个资源时，它可以释放已经占用的资源，等待其他进程释放它所需要的资源后再继续申请。这样可以避免循环等待条件的发生，从而避免死锁的发生。

