---
title: Java的内存模型如何解决可见性
date: 2023-05-03
tags:
 - Java
 - 并发编程
categories:
 - Java系列
---

### 什么是Java的内存模型？

> 导致可见性的原因是缓存，导致有序性的原因是编译优化，解决可见性、有序性最直接的办法就是**禁用缓存**和**编译优化**，但是需要**按需**禁用缓存和编译优化。

Java内存模型是指Java虚拟机（JVM）所使用的内存结构和操作规则，定义了多线程程序中的线程如何访问共享数据，并且确保这些访问是有序的、可靠和正确的。

Java的内存模型包括**主内存**和**工作内存**两部分。主内存是所有线程共享的内存区域，而工作内存是每个线程私有的内存区域。每个线程在执行过程中需要将共享变量从主内存复制到工作内存中，然后执行操作，最后将结果写回主内存。

总的说包括**volatile**、**synchronized**和**final**三个关键字，以及六项**Happens-Before**规则。

### volatile

使用volatile关键字可以保证可见性，即当一个线程修改了volatile变量的值后，其他线程能够立即看到这个修改的结果。

> 在1.5版本之前，`volatile`关键字并不能保证原子性，也就是说，如果多个线程同时修改同一个`volatile`变量，可能会出现竞争条件导致的非预期结果。从JDK 1.5开始，Java语言对`volatile`关键字的语义进行了扩展，除了保证可见性之外，还增加了禁止指令重排序和保证原子性的功能。因此，在JDK 1.5及以后的版本中，`volatile`关键字的作用更加强大。通过**Happens-Before**规则解决的。

### Happens-Before规则

> 前面一个操作的结果对后续操作是可见的

1. **程序的顺序性规则**：按照程序顺序，前面的操作Happens-Before于后续的任意操作。
2. **volatitle变量规则**：对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作。
3. **传递性**：a happens-before b, b happens-before c, => a happens-before c
4. **管程中锁的规则**：管程是一种同步原语，在Java中就是synchronized，是管程的实现。在进入同步块之前，会自动加锁，而在代码块执行完后自动释放锁，这个过程是编译实现的。
5. **线程start()规则**：关于启动线程的，主线程A启动子线程B，子线程B能够看到主线程在启动B前的操作。
6. **线程join()规则**：关于线程等待的，主线程能够看到子线程的操作。

### synchronized

使用synchronized关键字可以保证原子性和可见性，即同一时刻只有一个线程能够执行synchronized代码块或方法。

### final

使用final关键字可以保证可见性和有序性，即当一个final变量被初始化后，其他线程能够立即看到这个初始化的结果，并且不会发生重排序。

